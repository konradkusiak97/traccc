/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2021-2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// SYCL library include(s).
#include "../utils/get_queue.hpp"

// Spacepoint formation include(s).
#include "spacepoint_formation.hpp"

// SYCL include(s)
#include <CL/sycl.hpp>

namespace traccc::sycl {

void spacepoint_formation(
    spacepoint_container_view spacepoints_view,
    vecmem::data::vector_view<measurement> measurements_view,
    const cell_container_types::host& cells_per_event,
    vecmem::memory_resource& resource, queue_wrapper queue) {

    // The execution range of the kernel
    auto n_measurements = measurements_view.size();

    // Calculate the execution NDrange for the kernel
    auto wGroupSize = 64;
    auto num = (n_measurements + wGroupSize - 1) / wGroupSize;
    auto ndrange = ::sycl::nd_range<1>{::sycl::range<1>(num * wGroupSize),
                                       ::sycl::range<1>(wGroupSize)};

    // Get the view of the cells container
    auto cells_data = get_data(cells_per_event, &resource);
    cell_container_types::const_view cells_view(cells_data);

    details::get_queue(queue)
        .submit([&ndrange, &spacepoints_view, &measurements_view,
                 &cells_view](::sycl::handler& h) {
            h.parallel_for<class SpacepointFormation>(
                ndrange, [=](::sycl::nd_item<1> item) {
                    // Get the global idx
                    auto idx = item.get_global_linear_id();
                    device_measurement_collection measurements_device(
                        measurements_view);
                    device_spacepoint_container spacepoints_device(
                        spacepoints_view);

                    // Ignore if idx is out of range
                    if (idx >= measurements_device.size())
                        return;

                    // current module idx
                    const auto module_idx = measurements_device[idx].module_idx;

                    // current cell module
                    cell_container_types::const_device cells_device(cells_view);
                    const auto& module = cells_device.at(module_idx).header;

                    // Get the current measurement
                    const auto& m = measurements_device[idx];

                    // Form a spacepoint based on this measurement
                    point3 local_3d = {m.local[0], m.local[1], 0.};
                    point3 global = module.placement.point_to_global(local_3d);
                    spacepoint s({global, m});

                    // Push the speacpoint into the container at the appropriate
                    // module idx
                    spacepoints_device[module_idx].header = module.module;
                    spacepoints_device[module_idx].items.push_back(s);
                });
        })
        .wait_and_throw();
}

}  // namespace traccc::sycl
