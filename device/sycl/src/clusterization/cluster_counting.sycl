/** TRACCC library, part of the ACTS project (R&D line)
 *
 * (c) 2022 CERN for the benefit of the ACTS project
 *
 * Mozilla Public License Version 2.0
 */

// SYCL library include(s).
#include "../utils/get_queue.hpp"

// SYCL include(s).
#include <CL/sycl.hpp>

// Project include(s).
#include "cluster_counting.hpp"

#include <iostream>

namespace traccc::sycl {

void cluster_counting(
    const host_cell_container& cells_per_event,
    vecmem::data::jagged_vector_view<unsigned int> sparse_ccl_indices_view,
    vecmem::data::vector_view<std::size_t> cluster_sizes_view,
    vecmem::data::vector_view<std::size_t> cluster_prefix_sum_view,
    const std::size_t& cells_max,
    vecmem::memory_resource& resource, queue_wrapper queue) {

    // Execution size of the algorithm
    std::size_t N = cells_per_event.size();

    // Calculate the execution NDrange for the kernel
    auto workGroupSize = 32;
    auto num = (N + workGroupSize - 1) / workGroupSize;
    auto num2 = (cells_max + workGroupSize - 1) / workGroupSize; 
    auto ndrange = ::sycl::nd_range<2>{::sycl::range<2>(num*workGroupSize,num2*workGroupSize),
                                       ::sycl::range<2>(workGroupSize,workGroupSize)};

    // Get the view of the cells container
    auto cells_data = get_data(cells_per_event, &resource);
    cell_container_const_view cells_view(cells_data);

    details::get_queue(queue)
        .submit([&ndrange, &cells_view, 
                 &sparse_ccl_indices_view, cluster_sizes_view,
                 cluster_prefix_sum_view](::sycl::handler& h) {
            h.parallel_for<class ClusterCounting>(
                ndrange, [cells_view, sparse_ccl_indices_view,
                          cluster_sizes_view, cluster_prefix_sum_view](::sycl::nd_item<2> item) {
                    // Get the global index
                    auto idx = item.get_global_id(0);
                    auto idx_y = item.get_global_id(1);
                    // auto linear_idx = item.get_global_linear_id();

                    // Initialize the data on the device
                    device_cell_const_container cells_device(cells_view);
                    std::size_t N = cells_device.size();

                    // Ignore if idx is out of range
                    if (idx >= N)
                        return;

                    // Get the cells from the current module
                    const auto cells = cells_device.at(idx).items;

                    // Vectors used for cluster indices found by sparse CCL
                    vecmem::jagged_device_vector<unsigned int>
                        device_sparse_ccl_indices(sparse_ccl_indices_view);
                    const auto cluster_indices =
                        device_sparse_ccl_indices.at(idx);

                    // Number of clusters that sparce_ccl found for this module
                    // and the prefix sum at this thread idx
                    const auto num_clusters = cluster_indices.back();

                    vecmem::device_vector<std::size_t>
                        device_cluster_prefix_sum(cluster_prefix_sum_view);
                    const auto prefix_sum = device_cluster_prefix_sum[idx];

                    // Vector to fill in with sizes of each cluster
                    vecmem::device_vector<std::size_t> device_cluster_sizes(
                        cluster_sizes_view);

                    // Count the cluster sizes for each position
                    unsigned int cindex;
                    // for (std::size_t j = 0; j < cells.size(); ++j) {
                    //     cindex = cluster_indices[j] - 1;
                    //     if (cindex < num_clusters) {
                    //         device_cluster_sizes[prefix_sum + cindex]++;
                    //     }
                    // }
                    if (idx_y < cells.size()) {
                        cindex = cluster_indices[idx_y] - 1;
                        if (cindex < num_clusters) {
                            device_cluster_sizes[prefix_sum + cindex]++;
                        }
                    }
                });
        })
        .wait_and_throw();
}

}  // namespace traccc::sycl